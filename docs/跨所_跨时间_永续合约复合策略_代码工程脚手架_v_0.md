# 跨所·跨时间 永续合约复合策略 · 代码工程脚手架 v0.1

> 目标：将“跨所·跨时间 永续合约复合策略（价差 + 趋势跟随 + 资金费差）”落地为可运行的 Python 工程，覆盖：配置 → 适配层（Lighter/GRVT）→ 状态机（S0~S5）→ 原子下单/回滚 → 风控 → 监控 → 回测。

---

## 0. 快速开始（本地仿真）

```bash
# 1) 创建虚拟环境
python -m venv .venv && source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -U pip

# 2) 安装依赖
pip install pydantic~=2.8 httpx~=0.27 numpy~=2.0 pandas~=2.2 rich~=13.7
pip install websocket-client~=1.8 pyyaml~=6.0 tenacity~=9.0

# 3) 运行最小仿真（Mock 两所撮合，演示 S0→S5 状态迁移）
python src/main.py --mode mock --config configs/example.yml
```

> 说明：真实交易前需在 `.env` 填写两所 API Key，并先跑 **回测/仿真** 验证。

---

## 1. 项目结构（最小可用）

```
perp_cross_exchange/
├─ configs/
│  ├─ example.yml                # 参数模板（门槛、价差带、资金费保护…）
├─ src/
│  ├─ main.py                    # CLI 入口（mock/backtest/live）
│  ├─ config.py                  # 读取 YAML/ENV，提供 Settings 对象
│  ├─ types.py                   # TypedDict/Enums/数据结构
│  ├─ metrics.py                 # PnL/回撤/胜率/资金费/滑点统计
│  ├─ risk.py                    # 强平边界、净Delta上限、资金费保护
│  ├─ state_machine.py           # S0~S5 策略状态机（核心逻辑）
│  ├─ spread_monitor.py          # 价差与分位带计算、资金费窗口
│  ├─ execution/
│  │  ├─ atomic.py               # 原子下单/回滚、分批/滑点预算 IOC/FOK
│  │  └─ slippage.py             # L2 冲击/滑点估算（可mock）
│  ├─ exchanges/
│  │  ├─ base.py                 # 交易所抽象层（下单/撤单/仓位/资金费）
│  │  ├─ lighter.py              # Lighter 适配（占位：SDK对接点）
│  │  └─ grvt.py                 # GRVT 适配（占位：SDK对接点）
│  ├─ data/
│  │  ├─ feeders.py              # 行情/标记价/资金费推送（mock/真实）
│  │  └─ backfill.py             # 历史拉取与缓存（回测用）
│  └─ backtest/
│     ├─ engine.py               # 双所同时重放回测引擎
│     └─ fillsim.py              # 成交模拟（被动/主动/延迟/失败率）
├─ tests/
│  ├─ test_state_machine.py
│  └─ test_atomic_exec.py
├─ .env.example                  # API_KEY/SECRET、账户档位、返佣配置
├─ README.md
└─ pyproject.toml                # 可选：打包&依赖管理（或用 requirements.txt）
```

---

## 2. 配置（`configs/example.yml`）

```yaml
symbol: BTCUSDT
leverage: 10
base_qty: 0.01           # 名义第一腿仓位

# 入场门槛（>= 2 条满足）
thresholds:
  trend_strength: {ema_fast: 21, ema_slow: 55, min_diff: 0.0008}  # θ1
  min_target_return: 0.0035                                       # θ2（含费后）
  funding_spread_bps: 1.0                                         # θ3（单位：bp）
  vol_band: {vmin: 0.25, vmax: 2.5}                               # 实现波动过滤

# 锁盈/解锁参数
locking:
  g_pct: 0.005                 # P_lock 触发涨幅 g%
  band_sigma: 0.8              # LB/UB 以 σ 计算（或用分位见下）
  quantile_band: {lb: 0.2, ub: 0.8}
  t_max_sec: 14400             # 对锁最长持有（4h）
  epsilon_bp: 2.0              # 二腿分批带宽 ε（bp）

risk:
  stop_loss_first_leg: 0.01    # SL_1（1%）
  net_delta_max_ratio: 0.10    # |净敞口| ≤ 10% 名义
  isolated_margin: true        # 隔离保证金
  funding_guard_apr: 0.30      # 净资金费年化超过即切腿/降仓

fees:
  taker_bps: 2.0
  maker_rebate_bps: -0.5
  referral_rebate_bps: -0.2

exchanges:
  lighter:
    name: lighter
    endpoint: https://api.lighter.xyz
    account: default
  grvt:
    name: grvt
    endpoint: https://api.grvt.io
    account: default
```

---

## 3. 抽象层与适配器

### `src/exchanges/base.py`
```python
from __future__ import annotations
from typing import Protocol, TypedDict, Optional

class OrderReq(TypedDict):
    symbol: str
    side: str      # 'buy' or 'sell'
    qty: float
    type: str      # 'limit'|'market'|'ioc'|'fok'
    price: Optional[float]
    post_only: bool

class OrderAck(TypedDict):
    order_id: str
    status: str

class Position(TypedDict):
    qty: float
    entry_price: float
    leverage: float

class FundingInfo(TypedDict):
    next_rate: float  # 下个资金费率（小数）
    next_ts: int

class PerpExchange(Protocol):
    name: str
    def place_order(self, req: OrderReq) -> OrderAck: ...
    def cancel_order(self, order_id: str) -> None: ...
    def get_position(self, symbol: str) -> Position: ...
    def mark_price(self, symbol: str) -> float: ...
    def funding(self, symbol: str) -> FundingInfo: ...
    def leverage(self, symbol: str, x: float) -> None: ...
```

### `src/exchanges/lighter.py`（占位：对接官方 SDK）
```python
from .base import PerpExchange, OrderReq, OrderAck, Position, FundingInfo

class Lighter(PerpExchange):
    name = "lighter"
    def __init__(self, cfg):
        self.cfg = cfg
        # TODO: 初始化 lighter-python SDK 客户端

    def place_order(self, req: OrderReq) -> OrderAck:
        # TODO: 用 SDK 下单，返回标准化回执
        raise NotImplementedError

    def cancel_order(self, order_id: str) -> None:
        raise NotImplementedError

    def get_position(self, symbol: str) -> Position:
        raise NotImplementedError

    def mark_price(self, symbol: str) -> float:
        raise NotImplementedError

    def funding(self, symbol: str) -> FundingInfo:
        raise NotImplementedError

    def leverage(self, symbol: str, x: float) -> None:
        pass
```

### `src/exchanges/grvt.py`
```python
from .base import PerpExchange, OrderReq, OrderAck, Position, FundingInfo

class GRVT(PerpExchange):
    name = "grvt"
    def __init__(self, cfg):
        self.cfg = cfg
        # TODO: 初始化 grvt-pysdk 客户端

    def place_order(self, req: OrderReq) -> OrderAck:
        raise NotImplementedError

    def cancel_order(self, order_id: str) -> None:
        raise NotImplementedError

    def get_position(self, symbol: str) -> Position:
        raise NotImplementedError

    def mark_price(self, symbol: str) -> float:
        raise NotImplementedError

    def funding(self, symbol: str) -> FundingInfo:
        raise NotImplementedError

    def leverage(self, symbol: str, x: float) -> None:
        pass
```

---

## 4. 原子执行器 & 滑点预算

### `src/execution/atomic.py`
```python
from __future__ import annotations
from typing import Tuple
from ..exchanges.base import PerpExchange, OrderReq
from ..execution.slippage import budget_ok

class AtomicPairExecutor:
    """保证两腿要么同时成功，要么回滚第一腿。支持分批/IOC/FOK。"""
    def __init__(self, leg1: PerpExchange, leg2: PerpExchange, symbol: str):
        self.leg1, self.leg2, self.symbol = leg1, leg2, symbol

    def lock_pair(self, qty: float, p1: float, p2: float, epsilon_bp: float) -> Tuple[str, str]:
        # 1) 预算滑点
        if not budget_ok(self.symbol, qty, p1, p2, epsilon_bp):
            raise RuntimeError("slippage-budget-exceeded")
        # 2) 第一腿：被动优先，失败→小滑点 IOC
        o1 = self.leg1.place_order(OrderReq(symbol=self.symbol, side='buy', qty=qty, type='limit', price=p1, post_only=True))
        # （省略：等待成交+超时升级)
        # 3) 第二腿：镜像开空
        try:
            o2 = self.leg2.place_order(OrderReq(symbol=self.symbol, side='sell', qty=qty, type='ioc', price=p2, post_only=False))
        except Exception:
            # 3.1 回滚第一腿
            self.leg1.cancel_order(o1['order_id'])
            # （必要时对冲平掉已成交数量）
            raise
        return o1['order_id'], o2['order_id']
```

### `src/execution/slippage.py`
```python
def budget_ok(symbol: str, qty: float, p1: float, p2: float, epsilon_bp: float) -> bool:
    # TODO: 基于盘口 L2 估算冲击，这里先用占位逻辑
    allow = abs((p1 - p2) / ((p1 + p2) / 2)) * 1e4 <= epsilon_bp
    return allow
```

---

## 5. 策略状态机（S0~S5）

### `src/state_machine.py`
```python
from __future__ import annotations
from dataclasses import dataclass
from enum import Enum
from time import time
from .execution.atomic import AtomicPairExecutor
from .risk import Risk

class S(Enum):
    S0=0; S1=1; S2=2; S3=3; S4=4; S5=5

@dataclass
class Ctx:
    symbol: str
    leg_long: object   # Lighter 实例（多）
    leg_short: object  # GRVT 实例（空）
    risk: Risk
    cfg: dict
    state: S = S.S0
    first_leg_entry: float | None = None
    lock_time: float | None = None

class Strategy:
    def __init__(self, ctx: Ctx):
        self.c = ctx
        self.exec = AtomicPairExecutor(ctx.leg_long, ctx.leg_short, ctx.symbol)

    def on_tick(self, px_l: float, px_g: float, mark: float, funding_l: float, funding_g: float, ema_fast: float, ema_slow: float):
        now = time()
        if self.c.state == S.S0:
            if self._gate(ema_fast, ema_slow, px_l, funding_l, funding_g):
                self.c.first_leg_entry = px_l
                # 开第一腿（多）
                # TODO: 下单 & 止损保护
                self.c.state = S.S1
        elif self.c.state == S.S1:
            if px_l >= self.c.first_leg_entry * (1 + self.c.cfg['locking']['g_pct']):
                # 锁盈对锁
                # TODO: 调用 AtomicPairExecutor.lock_pair
                self.c.lock_time = now
                self.c.state = S.S3
        elif self.c.state == S.S3:
            spread = px_l - px_g
            # 基于分位或σ的 LB/UB 判定解锁
            if self._spread_ge_ub(spread):
                # 解锁A：平空 → S4
                self.c.state = S.S4
            elif self._spread_le_lb(spread):
                # 解锁B：平多 → S5
                self.c.state = S.S5
            elif now - (self.c.lock_time or now) > self.c.cfg['locking']['t_max_sec']:
                # 超时：保留资金费更友好的一腿
                # TODO: 比较 funding_l vs funding_g，择优保留
                self.c.state = S.S4  # 或 S5
        elif self.c.state == S.S4:
            # 仅多腿：反弹/时间/盈亏阈值离场
            pass
        elif self.c.state == S.S5:
            # 仅空腿：对称管理
            pass

    def _gate(self, ema_f, ema_s, price, f_l, f_g) -> bool:
        th = self.c.cfg['thresholds']
        cond_trend = (ema_f - ema_s) / price >= th['trend_strength']['min_diff']
        cond_ret   = True  # TODO: 以 θ2 估算到 P_lock 的净收益
        cond_f     = (f_l - f_g) * 1e4 >= th['funding_spread_bps']
        met = sum([cond_trend, cond_ret, cond_f]) >= 2
        return bool(met)

    def _spread_ge_ub(self, spread: float) -> bool:
        # TODO: 接入分位/σ计算
        return False

    def _spread_le_lb(self, spread: float) -> bool:
        return False
```

---

## 6. 风控与资金费保护

### `src/risk.py`
```python
from __future__ import annotations
from dataclasses import dataclass

@dataclass
class Risk:
    stop_loss_first_leg: float
    net_delta_max_ratio: float
    funding_guard_apr: float

    def can_add_exposure(self, net_delta: float, notional: float) -> bool:
        return abs(net_delta) <= self.net_delta_max_ratio * notional

    def hit_first_leg_sl(self, entry: float, last: float) -> bool:
        return (last - entry) / entry <= -self.stop_loss_first_leg

    def funding_guard(self, net_apr: float) -> bool:
        return net_apr <= self.funding_guard_apr
```

---

## 7. 回测/仿真

### `src/backtest/engine.py`
```python
import pandas as pd
from ..state_machine import Strategy, Ctx, S

class Backtest:
    def __init__(self, df: pd.DataFrame, ctx: Ctx):
        self.df, self.ctx = df, ctx
        self.strat = Strategy(ctx)
    def run(self):
        for row in self.df.itertuples(index=False):
            self.strat.on_tick(px_l=row.px_l, px_g=row.px_g, mark=row.mark,
                               funding_l=row.f_l, funding_g=row.f_g,
                               ema_fast=row.ema_f, ema_slow=row.ema_s)
        # TODO: 输出指标
```

---

## 8. CLI 入口

### `src/main.py`
```python
import argparse, yaml, os
from .config import load_settings
from .exchanges.lighter import Lighter
from .exchanges.grvt import GRVT
from .state_machine import Ctx, Strategy
from .risk import Risk

parser = argparse.ArgumentParser()
parser.add_argument('--mode', choices=['mock','backtest','live'], default='mock')
parser.add_argument('--config', required=True)
args = parser.parse_args()

cfg = load_settings(args.config)

if args.mode == 'mock':
    leg_long = Lighter(cfg['exchanges']['lighter'])   # TODO: 改为 Mock 实现
    leg_short = GRVT(cfg['exchanges']['grvt'])        # TODO: 改为 Mock 实现
else:
    leg_long = Lighter(cfg['exchanges']['lighter'])
    leg_short = GRVT(cfg['exchanges']['grvt'])

risk = Risk(**cfg['risk'])
ctx = Ctx(symbol=cfg['symbol'], leg_long=leg_long, leg_short=leg_short, risk=risk, cfg=cfg)
strat = Strategy(ctx)

print("[boot] strategy online (mode=", args.mode, ")")
# TODO: 接入数据源循环 / 回测引擎
```

---

## 9. 测试示例

### `tests/test_state_machine.py`
```python
from src.state_machine import Strategy, Ctx, S
from src.risk import Risk

class Dummy:
    name = "dummy"
    def place_order(self, req): return {"order_id":"1","status":"filled"}
    def cancel_order(self, oid): pass
    def get_position(self, s): return {"qty":0,"entry_price":0,"leverage":10}
    def mark_price(self, s): return 0
    def funding(self, s): return {"next_rate":0.0, "next_ts":0}
    def leverage(self, s, x): pass

def test_gate_and_lock():
    ctx = Ctx(symbol="BTCUSDT", leg_long=Dummy(), leg_short=Dummy(),
              risk=Risk(0.01,0.1,0.3), cfg={
                'thresholds':{
                  'trend_strength':{'min_diff':0.0008},
                  'min_target_return':0.0035,
                  'funding_spread_bps':1.0
                },
                'locking':{'g_pct':0.005, 't_max_sec':3600},
              })
    s = Strategy(ctx)
    s.on_tick(px_l=100, px_g=100, mark=100, funding_l=0.0002, funding_g=0.0001, ema_fast=102, ema_slow=100)
    assert s.c.state in (S.S1, S.S3)
```

---

## 10. 上线前清单（勾选）

- [ ] 真实 SDK 对接（签名、私有 WS、心跳/重连）
- [ ] 标记价/指数价源统一
- [ ] 资金费日历（不同所结算时点）
- [ ] 原子回滚 & 次优场所备份
- [ ] 强平边界 & 隔离保
- [ ] 滑点预算器（盘口 L2）
- [ ] 指标与告警面板（延迟/失败率/净敞口）

---

## 11. 备注

- 当前仓库为 **脚手架 v0.1**：核心框架与接口已齐备，真实交易需补全 SDK 接入、数据源与成交仿真。
- 代码风格尽量保持模块清晰、可单元测试、便于后续扩展（如引入策略版本化、回测参数扫描、风控规则热更新等）。

